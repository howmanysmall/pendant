import { createNamespaceLogger } from "logging/logger-utilities";
import { join } from "node:path";
import { fromPathLike } from "utilities/file-system-utilities";

const logger = createNamespaceLogger("add-to-gitignore-async");

/** Regex pattern to match leading slash or relative path prefix. */
const PREFIX_SLASH_REGEX = /^\/|^\.\//;

/** Default files that should be added to .gitignore for Luau/Roblox projects. */
const DEFAULT_IGNORE_FILES: ReadonlyArray<string> = [
	"sourcemap.json",
	"globalTypes.d.luau",
	"globalTypes.d.lua",
] as const;

/**
 * Normalizes a file path for .gitignore by ensuring it starts with a slash.
 *
 * @param fileName - The filename to normalize.
 * @returns The normalized filename with a leading slash.
 */
function normalizeIgnorePath(fileName: string): string {
	return `/${fileName.replace(PREFIX_SLASH_REGEX, "")}`;
}

/**
 * Checks if a .gitignore line matches any of the target files.
 *
 * @param line - The line from .gitignore to check.
 * @param targetFileNames - Set of normalized target filenames to match against.
 * @returns True if the line matches any target file.
 */
function lineMatchesTargetFile(line: string, targetFileNames: ReadonlySet<string>): boolean {
	const trimmedLine = line.trim();
	if (trimmedLine === "" || trimmedLine.startsWith("#")) return false;

	const normalizedLine = trimmedLine.replace(PREFIX_SLASH_REGEX, "");
	if (targetFileNames.has(normalizedLine)) return true;
	return Array.from(targetFileNames).some((fileName) => normalizedLine.endsWith(`/${fileName}`));
}

/**
 * Removes consecutive empty lines while preserving formatting.
 *
 * @param lines - Array of lines to clean.
 * @returns Array with consecutive empty lines removed.
 */
function cleanConsecutiveEmptyLines(lines: ReadonlyArray<string>): Array<string> {
	const result = new Array<string>();
	let length = 0;
	let wasEmpty = false;

	for (const line of lines) {
		const isEmpty = line.trim() === "";

		// Skip consecutive empty lines
		if (isEmpty && wasEmpty) continue;

		result[length++] = line;
		wasEmpty = isEmpty;
	}

	return result;
}

/**
 * Creates initial .gitignore content for a new file.
 *
 * @param outputFileName - The output filename to include.
 * @returns The complete .gitignore content with header and all required files.
 */
function createInitialContent(outputFileName: string): string {
	const normalizedOutput = normalizeIgnorePath(outputFileName);
	const normalizedDefaults = DEFAULT_IGNORE_FILES.map(normalizeIgnorePath);

	return `${["# Generated by Pendant", normalizedOutput, ...normalizedDefaults].join("\n")}\n`;
}

/**
 * Processes an existing .gitignore file to add missing target files.
 *
 * @param content - The existing .gitignore content.
 * @param outputFileName - The output filename to ensure is present.
 * @param verbose - Whether to log detailed operations.
 * @returns The updated .gitignore content.
 */
function processExistingContent(content: string, outputFileName: string, verbose: boolean): string {
	const lines = content.split("\n");
	const normalizedOutput = normalizeIgnorePath(outputFileName);
	const normalizedDefaults = DEFAULT_IGNORE_FILES.map(normalizeIgnorePath);
	const allTargetFiles = [normalizedOutput, ...normalizedDefaults];

	// Create lookup sets for performance
	const targetFileNames = new Set(allTargetFiles.map((file) => file.replace(PREFIX_SLASH_REGEX, "")));
	const seenLines = new Set<string>();
	const presentTargets = new Set<string>();
	const result = new Array<string>();
	let length = 0;

	// Process existing lines
	for (const line of lines) {
		// Skip duplicate lines
		if (seenLines.has(line)) {
			if (verbose) logger.debug(`Skipping duplicate line: ${line}`);
			continue;
		}
		seenLines.add(line);

		// Check if this line represents a target file
		if (lineMatchesTargetFile(line, targetFileNames)) {
			const normalizedLine = line.trim().replace(PREFIX_SLASH_REGEX, "");
			presentTargets.add(normalizedLine);
			if (verbose) logger.debug(`Found existing target: ${line}`);
		}

		result[length++] = line;
	}

	// Add missing target files
	for (const targetFile of allTargetFiles) {
		const normalizedTarget = targetFile.replace(PREFIX_SLASH_REGEX, "");
		if (!presentTargets.has(normalizedTarget)) {
			result[length++] = targetFile;
			if (verbose) logger.info(`Adding to .gitignore: ${targetFile}`);
		}
	}

	// Clean up formatting and ensure trailing newline
	const cleanedLines = cleanConsecutiveEmptyLines(result);
	const finalContent = cleanedLines.join("\n");

	return finalContent.endsWith("\n") ? finalContent : `${finalContent}\n`;
}

/**
 * Adds essential files to .gitignore for Luau/Roblox projects.
 *
 * This function intelligently manages .gitignore entries by adding required
 * files (sourcemap.json, globalTypes.d.luau, globalTypes.d.lua, and the
 * specified output file) while preserving existing content and avoiding
 * duplicates.
 *
 * @example
 *
 * ```ts
 * // Add default files to current directory
 * await addToGitIgnoreAsync();
 *
 * // Add custom output file with logging
 * await addToGitIgnoreAsync(process.cwd(), "build-output", true);
 * ```
 *
 * @param directoryPathLike - The directory containing the .gitignore file.
 * @param outputFileName - The custom output filename to add (defaults to
 *   "problematic").
 * @param verbose - Whether to enable detailed logging of operations.
 * @returns A Promise that resolves when the .gitignore has been updated.
 */
export default async function addToGitIgnoreAsync(
	directoryPathLike: Bun.PathLike = process.cwd(),
	outputFileName = "problematic",
	verbose = false,
): Promise<void> {
	const directory = fromPathLike(directoryPathLike);
	const gitIgnoreFile = Bun.file(join(directory, ".gitignore"));

	try {
		const exists = await gitIgnoreFile.exists();

		if (!exists) {
			// Create new .gitignore file
			if (verbose) logger.info(`Creating .gitignore in ${directory}`);
			const content = createInitialContent(outputFileName);
			await Bun.write(gitIgnoreFile, content);
			return;
		}

		// Process existing .gitignore file
		const existingContent = await gitIgnoreFile.text();
		const updatedContent = processExistingContent(existingContent, outputFileName, verbose);

		// Only write if content changed
		if (existingContent !== updatedContent) {
			await Bun.write(gitIgnoreFile, updatedContent);
			if (verbose) {
				logger.info(`Updated .gitignore in ${directory}`);
				logger.debug(`New content:\n${updatedContent}`);
			}
		} else if (verbose) logger.info("No .gitignore changes needed");
	} catch (error) {
		logger.error(`Failed to update .gitignore in ${directory}:`, error);
		throw error;
	}
}
